<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
    <title>SiliconFlow | 智能语音转文字</title>
    <style>
        :root {
            --primary: #111827; /* Black */
            --primary-hover: #374151; /* Dark Gray */
            --success: #10b981;
            --success-hover: #059669;
            --background: #f9fafb; /* Light Gray */
            --card-bg: #ffffff; /* White */
            --text-primary: #1f2937; /* Dark Text */
            --text-secondary: #6b7280; /* Medium Text */
            --border-color: #e5e7eb; /* Light Border */
            --border-radius: 1rem; /* 16px */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }


        .container {
            max-width: 720px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 2.5rem;
            animation: fadeIn 0.5s ease-out;
        }

        h1 {
            font-size: 2.25rem; /* 36px */
            font-weight: 800;
            letter-spacing: -0.025em;
            color: var(--text-primary);
        }
        
        h1 span {
            color: #E72410;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
            padding: 2.5rem; /* 40px */
            margin-bottom: 2.5rem;
            transition: all 0.3s ease;
            border: 1px solid var(--border-color);
        }

        .card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        /* 更新card-header布局 */
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            margin-bottom: 22px;
            color: var(--text-primary);
        }

        /* 验证区域样式 */
        #authSection {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        /* 验证按钮样式 */
        .verify-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 6px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: var(--shadow-sm);
            white-space: nowrap;
        }

        .verify-btn:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .verify-btn.verified {
            background: var(--success);
            box-shadow: 0 2px 6px rgba(34, 197, 94, 0.25);
            color: white;
        }

        .verify-btn.verified:hover {
            background: var(--success-hover);
            box-shadow: 0 3px 8px rgba(34, 197, 94, 0.3);
        }

        /* 验证状态文本样式 */
        .auth-status {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            white-space: nowrap;
            min-width: 60px;
            /* 给予一定最小宽度防止布局跳动 */
            text-align: left;
            transition: opacity 0.3s ease;
        }

        .auth-status.verified {
            color: var(--success);
        }

        .auth-status.error {
            color: #ef4444;
        }

        /* 缓存提示样式 */
        .cache-notice {
            background: #ecfdf5;
            border: 1px solid #a7f3d0;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 16px 0;
            display: none;
            align-items: center;
            gap: 12px;
            font-size: 0.9rem;
            color: #065f46;
            animation: slideDown 0.3s ease-out;
        }

        .cache-notice.visible {
            display: flex;
        }

        .cache-notice-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #10b981;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .cache-notice-icon svg {
            width: 12px;
            height: 12px;
            stroke: white;
            stroke-width: 2.5;
        }

        /* 缓存管理按钮 */
        .cache-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: var(--shadow-sm);
            margin-left: 8px;
        }

        .cache-btn:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #f3f4f6;
            color: var(--text-primary);
        }

        /* 缓存记录表格 */
        .cache-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }

        .cache-table th,
        .cache-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .cache-table th {
            background: #f9fafb;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .cache-table td {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .cache-table tr:hover {
            background: #f9fafb;
        }

        .cache-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .restore-btn {
            background: #e5e7eb; /* Light Gray */
            color: #374151; /* Dark Gray */
        }

        .restore-btn:hover {
            background: #d1d5db; /* Gray */
        }

        .delete-btn {
            background: #fee2e2;
            color: #b91c1c;
        }

        .delete-btn:hover {
            background: #fecaca;
        }

        .text-preview {
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: help;
            title: attr(data-full-text);
        }

        .empty-cache {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .clear-all-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            margin-top: 16px;
        }

        .clear-all-btn:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        /* 音频提取提示样式 */
        .audio-extraction-notice {
            background: #fef3c7;
            border: 1px solid #fde68a;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 16px 0;
            display: none;
            align-items: center;
            gap: 12px;
            font-size: 0.9rem;
            color: #92400e;
            animation: slideDown 0.3s ease-out;
        }

        .audio-extraction-notice.visible {
            display: flex;
        }

        .audio-extraction-notice .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(245, 158, 11, 0.3);
            border-top-color: #f59e0b;
        }

        @media (max-width: 480px) {
            .verify-btn {
                padding: 5px 12px;
                font-size: 0.8rem;
            }

            .auth-status {
                font-size: 0.8rem;
            }

            .cache-btn {
                padding: 5px 12px;
                font-size: 0.8rem;
            }
        }

        .icon-box {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            background: #f3f4f6; /* Lighter Gray */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-box.success {
            background: #d1fae5;
        }

        .icon-box svg {
            width: 24px;
            height: 24px;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .file-formats {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1.25rem 0;
        }

        .format-tag {
            background-color: #e5e7eb; /* Light Gray */
            color: #374151; /* Dark Gray */
            padding: 0.375rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .file-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 0.75rem;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            transition: all 0.2s ease-in-out;
            background-color: #f9fafb;
            margin-bottom: 1rem;
            cursor: pointer;
        }

        .file-upload-area:hover {
            border-color: var(--primary);
            background-color: #f3f4f6;
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            background-color: #f3f4f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--primary);
            stroke-width: 1.5;
        }

        .upload-text {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 500;
        }
        
        .upload-text span {
            color: var(--primary);
            font-weight: 600;
        }

        #fileInputLabel {
             /* We will style the parent drop area instead */
             display: none;
        }

        #fileName {
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow: var(--shadow-sm);
        }

        .btn:hover:not(:disabled) {
            background-color: var(--primary-hover);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
.url-actions-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
        }

        .url-actions-container .btn {
            flex-grow: 1;
            flex-basis: 0;
            padding: 12px 16px;
            font-size: 0.95rem;
        }

        .btn-download-video {
            background-color: var(--primary);
            box-shadow: var(--shadow-sm);
        }
        .btn-download-video:hover {
            background-color: var(--primary-hover);
        }

        .btn-download-audio {
            background-color: var(--primary);
            box-shadow: var(--shadow-sm);
        }
        .btn-download-audio:hover {
            background-color: var(--primary-hover);
        }

        #status {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 24px;
            font-size: 1.05rem;
            color: var(--text-primary);
            opacity: 0;
            height: 0;
            transition: all 0.3s;
        }

        #status.active {
            opacity: 1;
            height: auto;
            padding-top: 20px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-top-color: #1f2937;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .result-container {
            padding: 8px 0;
        }

        #result-box {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.5s ease;
        }

        #result-box.active {
            max-height: 350px;
        }

        #result {
            width: 100%;
            min-height: 250px;
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            background-color: #f9fafb;
            box-shadow: var(--shadow-sm);
            font-family: "SF Mono", Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9rem;
            line-height: 1.7;
            color: var(--text-primary);
            resize: vertical;
            transition: all 0.2s ease-in-out;
        }

        #result:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(17, 24, 39, 0.1);
        }

        /* 占位符样式优化 */
        #result::placeholder {
            color: var(--text-secondary);
            font-style: italic;
            opacity: 0.8;
        }

        /* 自定义滚动条样式 */
        #result::-webkit-scrollbar {
            width: 8px;
        }

        #result::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 8px;
        }

        #result::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 8px;
            transition: all 0.2s;
        }

        #result::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* 文本选中效果 */
        #result::selection {
            background: #dbeafe;
            color: inherit;
        }

        /* 复制按钮同一行右侧 */
        #copyBtn {
            background: var(--primary);
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: white;
            border: none;
            cursor: pointer;
        }

        #copyBtn.hidden {
            opacity: 0;
            visibility: hidden;
        }

        #timer {
            font-variant-numeric: tabular-nums;
            font-weight: 600;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .github-link {
                top: 15px;
                right: 15px;
            }

            .github-link svg {
                width: 28px;
                height: 28px;
            }

            .card-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }

            #authSection {
                align-self: flex-end;
            }

            .modal-content {
                margin: 20px;
                max-width: calc(100vw - 40px);
            }

            .cache-table {
                font-size: 0.8rem;
            }

            .cache-table th,
            .cache-table td {
                padding: 8px 6px;
            }

            .text-preview {
                max-width: 120px;
            }

            .container {
                margin: 20px auto;
            }

            .card {
                padding: 22px;
            }

            h1 {
                font-size: 2rem;
            }

            .btn {
                width: 100%;
                justify-content: center;
                padding: 14px;
            }

            /* 移动端上传区域改回垂直布局 */
            .file-upload-area {
                flex-direction: column;
                padding: 16px;
                gap: 12px;
            }

            .upload-text {
                white-space: normal;
                text-align: center;
            }

            #result {
                min-height: 180px;
                padding: 20px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .file-upload-area {
                gap: 8px;
            }

            .upload-icon {
                width: 36px;
                height: 36px;
            }

            #fileInputLabel {
                padding: 6px 16px;
                font-size: 0.85rem;
            }

            .upload-text {
                font-size: 0.9rem;
            }
        }
    </style>

<script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    let uploadedFileName = "transcript";

    const fileInput = document.querySelector('input[type=file]');
    if (fileInput) {
      fileInput.addEventListener("change", (e) => {
        if (e.target.files.length > 0) {
          uploadedFileName = e.target.files[0].name.replace(/\.[^/.]+$/, '');
          console.log("上传的文件名是：", uploadedFileName);
        }
      });
    }

    const btn = document.querySelector("#download-docx");
    if (btn) {
      btn.onclick = () => {
        const el = document.querySelector(".transcript") || document.querySelector("textarea");
        const text = el?.value || el?.innerText || "转录内容";
        const filename = uploadedFileName + ".docx";
        console.log("准备生成的 Word 文件名是：", filename);
        generateDocx(text, filename);
      };
    }
  });
</script>

<script>
  function generateDocx(text, filename) {
    const { Document, Packer, Paragraph } = window.docx;

    const doc = new Document({
      sections: [
        {
          properties: {},
          children: [new Paragraph(text)],
        },
      ],
    });

    Packer.toBlob(doc).then((blob) => {
      const docxFilename = filename.replace(/\.[^/.]+$/, '') + ".docx";
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = docxFilename;
      link.click();
    });
  }
</script>

</head>

<body>
    <div class="container">
        <header>
            <h1><span>SiliconFlow</span> 语音转文字</h1>
        </header>

        <div class="card">
            <div class="card-header">
                <div class="icon-box">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 0 1-3-3V4.5a3 3 0 1 1 6 0v8.25a3 3 0 0 1-3 3Z" />
                    </svg>
                </div>
                <h2>上传音视频文件</h2>
                <div id="authSection" style="display:flex; align-items:center; gap:8px;">
                    <button type="button" id="cacheBtn" class="cache-btn">缓存记录</button>
                    <button type="button" id="verifyBtn" class="verify-btn">口令验证</button>
                    <span id="authStatus" class="auth-status"></span>
                </div>
            </div>

            <!-- 缓存提示区域 (Green) -->
            <div id="cacheNotice" class="cache-notice">
                <div class="cache-notice-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                </div>
                <span id="cacheNoticeText">该文件已转写过，从本地缓存中恢复识别结果</span>
            </div>

            <!-- 音频提取提示区域 (Amber) -->
            <div id="extractionNotice" class="audio-extraction-notice">
                <div class="spinner"></div>
                <span id="extractionNoticeText">正在从视频中提取音频...</span>
            </div>

            <p>支持以下格式的音频/视频文件转换（最大文件大小：100MB）</p>
            <div class="file-formats">
                <div class="format-tag">MP3</div>
                <div class="format-tag">WAV</div>
                <div class="format-tag">PCM</div>
                <div class="format-tag">OPUS</div>
                <div class="format-tag">WEBM</div>
                <div class="format-tag">MP4*</div>
                <div class="format-tag">MOV*</div>
                <div class="format-tag">AVI*</div>
            </div>
            <form id="uploadForm">
                <div class="file-upload-area" id="dropArea">
                    <div class="upload-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
                        </svg>
                    </div>
                    <span class="upload-text">拖放文件到此处，或 <span>点击选择文件</span></span>
                    <input type="file" id="fileInput" name="file" accept="audio/*,video/*" style="display: none;" />
                </div>

                <div id="fileInfoArea"
                    style="margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary); text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span id="fileName">未选择任何文件</span>
                    <!-- The download link will be injected here by JavaScript -->
                </div>
                <input type="hidden" name="model" value="FunAudioLLM/SenseVoiceSmall" />
                <div style="margin-top: 24px; text-align: center;">
                    <button class="btn" type="submit" id="submitBtn">开始语音转写</button>
                </div>
            </form>

            <div style="text-align: center; margin: 20px 0; color: var(--text-secondary); font-size: 0.9rem;">或</div>

            <div class="url-input-area" style="margin-bottom: 16px; position: relative;">
                <input type="text" id="videoUrlInput"
                    style="width: 100%; padding: 12px 16px; border-radius: 8px; border: 1px solid var(--border-color); transition: all 0.2s; font-size: 0.95rem; background: var(--card-bg); color: var(--text-primary);"
                    placeholder="在此处粘贴视频或抖音分享链接">
            </div>
            <div id="urlActions" class="url-actions-container">
                <button class="btn" id="douyinParseBtn">抖音解析转写</button>
                <a href="#" id="downloadVideoBtn" class="btn btn-download-video" style="display: none;" download>下载视频</a>
                <a href="#" id="downloadAudioBtn" class="btn btn-download-audio" style="display: none;" download>下载音频</a>
            </div>

            <div id="status">
                <div class="spinner"></div>
                <div>AI正在处理中... <span id="timer">0s</span></div>
            </div>
        </div>

        <div class="result-container">
            <div class="card-header result">
                <div class="icon-box success" style="display: none;"></div>
                <h2>识别结果</h2>
                <button id="copyBtn" class="hidden">复制</button>
            </div>
            <div id="result-box">
                <textarea id="result" readonly placeholder="识别结果会显示在这里..."></textarea>
            </div>
        </div>
    </div>

    <!-- 缓存管理模态框 -->
    <div id="cacheModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>本地缓存记录</h3>
                <button class="close-btn" id="closeModal">×</button>
            </div>
            <div id="cacheTableContainer">
                <!-- 缓存记录表格将在这里动态生成 -->
            </div>
        </div>
    </div>

    <script>
        let isVerified = false;
        let cacheKey = null;
        let timerInterval;
        let authStatusTimer; // Timer for hiding the auth status message
        const AUTH_KEY = 'sf_auth_status';
        const verifyBtn = document.getElementById('verifyBtn');
        const cacheBtn = document.getElementById('cacheBtn');
        const authStatus = document.getElementById('authStatus');
        const uploadForm = document.getElementById('uploadForm');
        const submitBtn = document.getElementById('submitBtn');
        const statusDiv = document.getElementById('status');
        const timerSpan = document.getElementById('timer');
        const fileInput = document.getElementById('fileInput');
        const fileNameDiv = document.getElementById('fileName');
        const dropArea = document.getElementById('dropArea');
        const resultBox = document.getElementById('result-box');
        const resultArea = document.getElementById('result');
        const copyBtn = document.getElementById('copyBtn');
        const cacheNotice = document.getElementById('cacheNotice');
        const cacheNoticeText = document.getElementById('cacheNoticeText');
        const cacheModal = document.getElementById('cacheModal');
        const closeModal = document.getElementById('closeModal');
        const extractionNotice = document.getElementById('extractionNotice');
        const extractionNoticeText = document.getElementById('extractionNoticeText');
        const videoUrlInput = document.getElementById('videoUrlInput');
        const douyinParseBtn = document.getElementById('douyinParseBtn');
        const downloadVideoBtn = document.getElementById('downloadVideoBtn');
        const downloadAudioBtn = document.getElementById('downloadAudioBtn');

        // 检查文件是否为视频格式
        function isVideoFile(file) {
            const videoTypes = ['video/mp4', 'video/mov', 'video/quicktime', 'video/avi', 'video/x-msvideo'];
            return videoTypes.includes(file.type) || /\.(mp4|mov|avi|webm)$/i.test(file.name);
        }

        // 检查文件是否为支持的音频格式
        function isSupportedAudioFile(file) {
            const supportedTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/opus', 'audio/webm'];
            return supportedTypes.includes(file.type) || /\.(mp3|wav|opus|webm|pcm)$/i.test(file.name);
        }

        function createWavFromAudioBuffer(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            let interleaved = new Int16Array(audioBuffer.length * numChannels);
            let offset = 0;
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    let sample = audioBuffer.getChannelData(channel)[i];
                    sample = Math.max(-1, Math.min(1, sample));
                    interleaved[offset++] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                }
            }

            const buffer = new ArrayBuffer(44 + interleaved.length * 2);
            const view = new DataView(buffer);

            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            const blockAlign = numChannels * (bitDepth / 8);
            const byteRate = sampleRate * blockAlign;
            const dataSize = interleaved.length * 2;

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            for (let i = 0; i < interleaved.length; i++) {
                view.setInt16(44 + i * 2, interleaved[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        async function extractAudioFromVideo(videoFile) {
            return new Promise(async (resolve, reject) => {
                extractionNotice.classList.add('visible');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                try {
                    extractionNoticeText.textContent = '正在读取视频文件...';
                    const arrayBuffer = await videoFile.arrayBuffer();

                    extractionNoticeText.textContent = '正在解码音频轨道...';
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                    const targetSampleRate = 16000;
                    const duration = audioBuffer.duration;

                    extractionNoticeText.textContent = '正在处理音频（转为16kHz单声道）...';
                    const offlineContext = new OfflineAudioContext(1, duration * targetSampleRate, targetSampleRate);

                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start();

                    const renderedBuffer = await offlineContext.startRendering();

                    extractionNoticeText.textContent = '正在生成WAV文件...';
                    const wavBlob = createWavFromAudioBuffer(renderedBuffer);

                    resolve(wavBlob);
                } catch (error) {
                    console.error("音频提取失败:", error);
                    let userMessage = `无法从视频中提取音频。\n\n可能原因：\n1. 视频文件没有音轨。\n2. 音频编码格式不受浏览器支持。\n\n建议：转换视频格式后再试。`;
                    reject(new Error(userMessage));
                } finally {
                    if (audioContext.state !== 'closed') audioContext.close();
                    extractionNotice.classList.remove('visible');
                }
            });
        }

        function checkFileSizeAndWarn(file) {
            const sizeMB = file.size / (1024 * 1024);
            const maxRecommendedSize = 100; // 100MB

            if (sizeMB > maxRecommendedSize) {
                const proceed = confirm(
                    `文件较大 (${sizeMB.toFixed(1)}MB)，提取音频可能需要较长时间。\n` +
                    `建议压缩视频或使用较小的文件。\n\n` +
                    `是否继续？`
                );
                return proceed;
            }
            return true;
        }

        function checkAuthStatus() {
            const authData = localStorage.getItem(AUTH_KEY);
            if (authData) {
                try {
                    const { verified, timestamp } = JSON.parse(authData);
                    const isExpired = Date.now() - timestamp > 7 * 24 * 60 * 60 * 1000;
                    if (verified && !isExpired) {
                        isVerified = true;
                        updateAuthUI(true);
                        return;
                    }
                } catch (e) {
                    console.error('解析认证数据失败:', e);
                }
            }
            updateAuthUI(false);
        }

        function updateAuthUI(verified) {
            if (verified) {
                verifyBtn.textContent = '已验证';
                verifyBtn.classList.add('verified');
                submitBtn.disabled = !fileInput.files[0] && !fileInput.processedFile;
                douyinParseBtn.disabled = false;
            } else {
                verifyBtn.textContent = '口令验证';
                verifyBtn.classList.remove('verified');
                submitBtn.disabled = true;
                douyinParseBtn.disabled = true;
            }
            authStatus.textContent = '';
            authStatus.className = 'auth-status';
        }

        function saveAuthStatus(verified) {
            const authData = {
                verified,
                timestamp: Date.now()
            };
            localStorage.setItem(AUTH_KEY, JSON.stringify(authData));
        }

        verifyBtn.addEventListener('click', async () => {
            if (isVerified) {
                const action = confirm('当前已验证通过，是否要退出登录？');
                if (action) {
                    isVerified = false;
                    localStorage.removeItem(AUTH_KEY);
                    updateAuthUI(false);
                }
                return;
            }

            const token = prompt('请输入口令：');
            if (!token) return;

            try {
                const res = await fetch('/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });
                const { valid } = await res.json();

                isVerified = valid;
                clearTimeout(authStatusTimer);

                if (valid) {
                    saveAuthStatus(true);
                    updateAuthUI(true);
                    authStatus.textContent = '验证通过';
                    authStatus.className = 'auth-status verified';
                    authStatusTimer = setTimeout(() => {
                        authStatus.textContent = '';
                        authStatus.className = 'auth-status';
                    }, 2000);
                } else {
                    authStatus.textContent = '口令错误';
                    authStatus.className = 'auth-status error';
                    authStatusTimer = setTimeout(() => {
                        authStatus.textContent = '';
                        authStatus.className = 'auth-status';
                    }, 3000);
                }
            } catch (err) {
                console.error('验证失败:', err);
                clearTimeout(authStatusTimer);
                authStatus.textContent = '验证失败';
                authStatus.className = 'auth-status error';
                authStatusTimer = setTimeout(() => {
                    authStatus.textContent = '';
                    authStatus.className = 'auth-status';
                }, 3000);
            }
        });

        cacheBtn.addEventListener('click', () => {
            showCacheModal();
        });

        closeModal.addEventListener('click', () => {
            cacheModal.classList.remove('active');
        });

        cacheModal.addEventListener('click', (e) => {
            if (e.target === cacheModal) {
                cacheModal.classList.remove('active');
            }
        });

        function showCacheModal() {
            const cacheRecords = getCacheRecords();
            const container = document.getElementById('cacheTableContainer');

            if (cacheRecords.length === 0) {
                container.innerHTML = `<div class="empty-cache"><p>暂无缓存记录</p></div>`;
            } else {
                const tableHTML = `
          <table class="cache-table">
            <thead>
              <tr>
                <th>文件名</th><th>大小</th><th>时间</th><th>识别结果预览</th><th>操作</th>
              </tr>
            </thead>
            <tbody>
              ${cacheRecords.map((record) => `
                <tr>
                  <td title="${record.name}">${truncateText(record.name, 20)}</td>
                  <td>${record.size > 0 ? (record.size / 1024 / 1024).toFixed(2) + 'MB' : '来自链接'}</td>
                  <td>${formatDate(record.timestamp)}</td>
                  <td class="text-preview" data-full-text="${record.text}" title="${record.text}">
                    ${truncateText(record.text, 30)}
                  </td>
                  <td class="cache-actions">
                    <button class="action-btn restore-btn" onclick="restoreRecord('${record.key}')">恢复</button>
                    <button class="action-btn delete-btn" onclick="deleteRecord('${record.key}')">删除</button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
          <button class="clear-all-btn" onclick="clearAllCache()">清空所有缓存</button>
        `;
                container.innerHTML = tableHTML;
            }

            cacheModal.classList.add('active');
        }

        function getCacheRecords() {
            const records = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('sf_cache_')) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        records.push({ key, ...data, timestamp: data.timestamp || Date.now() });
                    } catch (e) { console.error('解析缓存记录失败:', e); }
                }
            }
            return records.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        }

        function truncateText(text, maxLength) {
            if (!text) return '';
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        function formatDate(timestamp) {
            if (!timestamp) return '未知';
            return new Date(timestamp).toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        }

        window.restoreRecord = function (key) {
            try {
                const data = JSON.parse(localStorage.getItem(key));
                resultArea.value = data.text;
                resultBox.classList.add('active');
                copyBtn.classList.remove('hidden');
                cacheModal.classList.remove('active');

                cacheNoticeText.textContent = '该文件已转写过，从本地缓存中恢复识别结果';
                cacheNotice.classList.add('visible');
                setTimeout(() => { cacheNotice.classList.remove('visible'); }, 5000);

            } catch (e) { alert('恢复记录失败'); }
        };

        window.deleteRecord = function (key) {
            if (confirm('确定要删除这个缓存记录吗？')) {
                localStorage.removeItem(key);
                showCacheModal();
            }
        };

        window.clearAllCache = function () {
            if (confirm('确定要清空所有缓存记录吗？此操作不可恢复。')) {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('sf_cache_')) {
                        keys.push(key);
                    }
                }
                keys.forEach(key => localStorage.removeItem(key));
                showCacheModal();
            }
        };

        fileInput.addEventListener('change', async () => {
            const file = fileInput.files[0];
            const fileInfoArea = document.getElementById('fileInfoArea');
            fileInfoArea.innerHTML = `<span id="fileName">未选择任何文件</span>`;
            downloadVideoBtn.style.display = 'none';
            downloadAudioBtn.style.display = 'none';
            if (!file) {
                updateAuthUI(isVerified);
                return;
            }

            cacheNotice.classList.remove('visible');
            extractionNotice.classList.remove('visible');

            let processedFile = file;

            try {
                if (isVideoFile(file)) {
                    if (!checkFileSizeAndWarn(file)) { fileInput.value = ''; return; }
                    try {
                        const startTime = Date.now();
                        processedFile = await extractAudioFromVideo(file);
                        const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
                        const newSizeMB = (processedFile.size / 1024 / 1024).toFixed(2);
                        const newName = file.name.replace(/\.[^/.]+$/, '_extracted.wav');
                        processedFile.name = newName;

                        const fileNameText = `${newName} (${newSizeMB} MB) - 提取耗时 ${processingTime}s`;
                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(processedFile);
                        downloadLink.download = newName;
                        downloadLink.textContent = '下载音频';
                        downloadLink.style.cssText = `background:var(--primary);color:white;padding:4px 10px;border-radius:6px;text-decoration:none;font-weight:500;`;
                        fileInfoArea.innerHTML = `<span id="fileName">${fileNameText}</span>`;
                        fileInfoArea.appendChild(downloadLink);
                    } catch (error) {
                        alert(`音频提取失败: ${error.message}`);
                        fileInput.value = '';
                        return;
                    }
                } else if (isSupportedAudioFile(file)) {
                    const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                    document.getElementById('fileName').textContent = `${file.name} (${sizeMB} MB)`;
                } else {
                    alert('不支持的文件格式。请上传 MP3、WAV、OPUS 等音频或 MP4、MOV 等视频文件。');
                    fileInput.value = '';
                    return;
                }

                fileInput.processedFile = processedFile;
                fileInput.originalFile = file;
                submitBtn.disabled = !isVerified;

                const arrayBuffer = await processedFile.arrayBuffer();
                const md5 = SparkMD5.ArrayBuffer.hash(arrayBuffer);
                cacheKey = `sf_cache_${md5}`;

                const cachedRaw = localStorage.getItem(cacheKey);
                if (cachedRaw) {
                    try {
                        const cachedData = JSON.parse(cachedRaw);
                        const matchName = isVideoFile(file) ? file.name : processedFile.name || file.name;
                        if (cachedData.originalName === matchName) {
                            window.restoreRecord(cacheKey);
                            return;
                        }
                        resultBox.classList.remove('active');
                        copyBtn.classList.add('hidden');
                        updateAuthUI(isVerified);
                    } catch (e) {
                        console.error('解析缓存失败:', e);
                    }
                }

                resultBox.classList.remove('active');
                copyBtn.classList.add('hidden');

            } catch (error) {
                console.error('文件处理失败:', error);
                extractionNotice.classList.remove('visible');
                alert('文件处理失败：' + error.message);
                fileInput.value = '';
            }
        });

        ['dragenter', 'dragover'].forEach(evt => dropArea.addEventListener(evt, e => {
            e.preventDefault();
            dropArea.classList.add('hover');
        }));

        ['dragleave', 'drop'].forEach(evt => dropArea.addEventListener(evt, e => {
            e.preventDefault();
            dropArea.classList.remove('hover');
        }));

        dropArea.addEventListener('drop', e => {
            const files = e.dataTransfer.files;
            if (files.length) {
                fileInput.files = files;
                fileInput.dispatchEvent(new Event('change'));
            }
        });

        statusDiv.classList.remove('active');
        resultBox.classList.remove('active');
        checkAuthStatus();

        uploadForm.addEventListener('submit', async e => {
            e.preventDefault();

            if (!isVerified) {
                alert('请先完成口令验证');
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                alert('请选择一个文件');
                return;
            }

            submitBtn.disabled = true;
            resultArea.value = '';
            copyBtn.classList.add('hidden');
            resultBox.classList.remove('active');
            statusDiv.classList.add('active');
            cacheNotice.classList.remove('visible');

            let seconds = 0;
            timerSpan.textContent = '0s';
            timerInterval = setInterval(() => {
                seconds++;
                timerSpan.textContent = `${seconds}s`;
            }, 1000);

dropArea.addEventListener('click', () => {
            fileInput.click();
        });
            try {
                let fileToUpload = fileInput.processedFile || file;
                let originalFile = fileInput.originalFile || file;
                originalFile.nameForCache = originalFile.name;

                const arrayBufferForHash = await fileToUpload.arrayBuffer();
                const md5 = SparkMD5.ArrayBuffer.hash(arrayBufferForHash);
                const currentCacheKey = `sf_cache_${md5}`;

                const cachedRaw = localStorage.getItem(currentCacheKey);
                if (cachedRaw) {
                    const cachedData = JSON.parse(cachedRaw);
                    if (cachedData.originalName === originalFile.nameForCache) {
                        window.restoreRecord(currentCacheKey);
                        clearInterval(timerInterval);
                        statusDiv.classList.remove('active');
                        submitBtn.disabled = !isVerified;
                        return;
                    }
                }

                const formData = new FormData();
                formData.append('file', fileToUpload, fileToUpload.name || 'extracted_audio.wav');
                formData.append('model', 'FunAudioLLM/SenseVoiceSmall');

                const res = await fetch('/transcribe', { method: 'POST', body: formData });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);

                const data = await res.json();
                resultArea.value = data.text;

                resultBox.classList.add('active');
                copyBtn.classList.remove('hidden');

                const payload = {
                    name: fileToUpload.name || 'extracted_audio.wav',
                    originalName: originalFile.nameForCache,
                    size: fileToUpload.size,
                    text: data.text,
                    timestamp: Date.now(),
                    isExtracted: !!fileInput.processedFile
                };
                localStorage.setItem(currentCacheKey, JSON.stringify(payload));

            } catch (err) {
                console.error('转写失败:', err);
                resultArea.value = '转写失败：' + err.message;
                resultBox.classList.add('active');
            } finally {
                clearInterval(timerInterval);
                statusDiv.classList.remove('active');
                extractionNotice.classList.remove('visible');
                submitBtn.disabled = !isVerified;
            }
        });

        async function transcribeFromUrl() {
            if (!isVerified) {
                alert('请先完成口令验证');
                return;
            }

            const videoUrl = videoUrlInput.value.trim();
            if (!videoUrl) {
                alert('请粘贴一个链接');
                return;
            }

            douyinParseBtn.disabled = true;
            downloadVideoBtn.style.display = 'none';
            downloadAudioBtn.style.display = 'none';
            resultArea.value = '';
            copyBtn.classList.add('hidden');
            resultBox.classList.remove('active');
            statusDiv.classList.add('active');
            cacheNotice.classList.remove('visible');
            fileNameDiv.textContent = ''; // 清除文件名显示

            let seconds = 0;
            timerSpan.textContent = '0s';
            timerInterval = setInterval(() => {
                seconds++;
                timerSpan.textContent = `${seconds}s`;
            }, 1000);

            try {
                // 1. 解析分享链接中的URL
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const matches = videoUrl.match(urlRegex);
                if (!matches) throw new Error('未在输入中找到有效的URL');
                const extractedUrl = matches[0];

                // 2. 检查缓存
                const urlHash = SparkMD5.hash(extractedUrl);
                const currentCacheKey = `sf_cache_${urlHash}`;
                const cachedRaw = localStorage.getItem(currentCacheKey);
                if (cachedRaw) {
                    const cachedData = JSON.parse(cachedRaw);
                    if (cachedData.originalName === extractedUrl) {
                        window.restoreRecord(currentCacheKey);
                        clearInterval(timerInterval);
                        statusDiv.classList.remove('active');
                        douyinParseBtn.disabled = !isVerified;
                        return;
                    }
                }

                // 3. 从后端获取视频直链
                extractionNotice.classList.add('visible');
                extractionNoticeText.textContent = '正在解析视频直链...';
                const resolverResponse = await fetch('/parse-url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: extractedUrl })
                });
                if (!resolverResponse.ok) {
                    const errorText = await resolverResponse.text();
                    throw new Error(`解析失败 (HTTP ${resolverResponse.status}): ${errorText}`);
                }
                const { directUrl: directVideoUrl } = await resolverResponse.json();
                if (!directVideoUrl || !directVideoUrl.startsWith('http')) {
                    throw new Error('无法从API返回中解析出有效的视频直链');
                }

                // 4. 通过我们的后端代理下载视频，以绕过CORS限制
                extractionNoticeText.textContent = '正在下载视频文件...';
                const videoResponse = await fetch('/proxy-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: directVideoUrl })
                });
                if (!videoResponse.ok) throw new Error('通过代理下载视频文件失败');
                const videoBlob = await videoResponse.blob();

                // 使“下载视频”按钮可用
                downloadVideoBtn.href = URL.createObjectURL(videoBlob);
                downloadVideoBtn.download = `douyin_video_${Date.now()}.mp4`;
                downloadVideoBtn.style.display = 'inline-flex';


                // 5. 在前端提取音频
                // 我们需要给 videoBlob 一个 name 属性，以便 extractAudioFromVideo 函数使用
                videoBlob.name = `douyin_video_${Date.now()}.mp4`;
                if (!checkFileSizeAndWarn(videoBlob)) {
                    throw new Error("操作取消：文件过大。");
                }
                const audioWavBlob = await extractAudioFromVideo(videoBlob);

                // 使“下载音频”按钮可用
                downloadAudioBtn.href = URL.createObjectURL(audioWavBlob);
                downloadAudioBtn.download = `douyin_audio_${Date.now()}.wav`;
                downloadAudioBtn.style.display = 'inline-flex';

                // 6. 上传提取出的音频文件
                extractionNoticeText.textContent = '正在上传音频并转写...';
                const formData = new FormData();
                formData.append('file', audioWavBlob, 'extracted_audio.wav');
                formData.append('model', 'FunAudioLLM/SenseVoiceSmall');

                const res = await fetch('/transcribe', { method: 'POST', body: formData });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                
                const data = await res.json();
                if (data.code && data.code !== 200) throw new Error(data.message || `API返回错误码: ${data.code}`);
                resultArea.value = data.text;

                resultBox.classList.add('active');
                copyBtn.classList.remove('hidden');

                // 7. 保存到缓存
                const payload = {
                    name: `抖音视频 - ${new URL(extractedUrl).pathname.split('/').pop()}`,
                    originalName: extractedUrl,
                    size: 0, // 大小对于URL转写不重要
                    text: data.text,
                    timestamp: Date.now(),
                    isExtracted: true
                };
                localStorage.setItem(currentCacheKey, JSON.stringify(payload));


            } catch (err) {
                console.error('转写失败:', err);
                resultArea.value = '转写失败：' + err.message;
                resultBox.classList.add('active');
            } finally {
                clearInterval(timerInterval);
                statusDiv.classList.remove('active');
                extractionNotice.classList.remove('visible');
                douyinParseBtn.disabled = !isVerified;
            }
        }

        douyinParseBtn.addEventListener('click', transcribeFromUrl);

        copyBtn.addEventListener('click', () => {
            if (!resultArea.value) return;
            navigator.clipboard.writeText(resultArea.value).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '已复制';
                setTimeout(() => { copyBtn.textContent = originalText; }, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
                resultArea.select();
                document.execCommand('copy');
                copyBtn.textContent = '已复制';
                setTimeout(() => { copyBtn.textContent = '复制'; }, 2000);
            });
        });

        videoUrlInput.addEventListener('input', () => {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const matches = videoUrlInput.value.match(urlRegex);
            if (matches && matches.length > 0) {
                // 如果检测到URL，用第一个匹配到的URL替换输入框的全部内容
                if (videoUrlInput.value !== matches[0]) {
                    videoUrlInput.value = matches[0];
                }
            }
        });
    </script>

<script>
document.getElementById("download-docx")?.addEventListener("click", () => {
  const textEl = document.querySelector(".transcript") || document.querySelector("textarea");
  const text = textEl?.value || textEl?.innerText || "转录内容";
  const filename = "transcript.docx";
  generateDocx(text, filename);
});
</script>


<script>
window.addEventListener("load", () => {
  const transcriptEl = document.querySelector(".transcript") || document.querySelector("textarea");

  if (transcriptEl) {
    const btn = document.createElement("button");
    btn.id = "download-docx";
    btn.textContent = "下载 Word";
    btn.style.marginTop = "10px";
    btn.style.marginLeft = "8px";
    btn.style.padding = "6px 12px";
    btn.style.borderRadius = "6px";
    btn.style.border = "1px solid #ccc";
    btn.style.background = "#f2f2f2";
    btn.style.cursor = "pointer";

    transcriptEl.parentNode.insertBefore(btn, transcriptEl.nextSibling);

    btn.addEventListener("click", () => {
      const text = transcriptEl.value || transcriptEl.innerText || "转录内容";
      const filename = "transcript.docx";
      generateDocx(text, filename);
    });
  }
});
</script>

</body>

</html>